/*
Author: Mitchell Ludwig
Functions: parseMultipartFormdata(dataBuffer)
*/
var bops = require('bufferOps');

//This test buffer is simply the an example of the format of a multipart/formdata
// encoded Buffer
//exports.testBuffer = new Buffer("-----------------------------18621512727577\r\nContent-Disposition: form-data; name=\"MAX_FILE_SIZE\"\r\n\r\n500\r\n-----------------------------18621512727577\r\nContent-Disposition: form-data; name=\"uploadfile\"; filename=\"ciphertext.txt\"\r\nContent-Type: text/plain\r\n\r\nSIJYUMNVCAISPJLRBZEYQWYEULWMGWICJCIMTZEIMIBKNQWBRIVWYIGBWNBQQ\r\n-----------------------------18621512727577--\r\n");
/*
parseMultipartFormdata returns an array of Buffers containing the data for the form object
 with indicies being the names in the form.
One simply needs to pass in a full multipart/formdata encoded Buffer, and then you can 
access the data like so:
 x = require('uploadOps').parseMultipartFormdata(dataBuffer);
 console.log(x[MAX_FILE_SIZE].toString());
and on the console you will see the string '500'

This function is for extracting data from a multipart/formdata encoded Buffer,
 which looks like:
-----------------------------18621512727577
Content-Disposition: form-data; name="MAX_FILE_SIZE"

500
-----------------------------18621512727577
Content-Disposition: form-data; name="uploadfile"; filename="ciphertext.txt"
Content-Type: text/plain

SIJYUMNVCAISPJLRBZEYQWYEULWMGWICJCIMTZEIMIBKNQWBRIVWYIGBWNBQQ
-----------------------------18621512727577--

*/
parseMultipartFormdata = function (dataBuffer) {
        //Buffer representing the linefeed character
        var lineFeed = new Buffer(1);
        lineFeed[0]=10;
        //Buffer containing two CRLFs
        var crlfcrlfBuffer = new Buffer(4);
        crlfcrlfBuffer[0]=13;
        crlfcrlfBuffer[1]=10;
        crlfcrlfBuffer[2]=13;
        crlfcrlfBuffer[3]=10;
        
        //Buffer representing the 'name="' string
        var nameBuffer = new Buffer("name=\"");
        
        //Buffer representing the '"' string
        var quoteBuffer = new Buffer("\"");
        
        //Grab the first line, which separates all of the entries in the form data
        var sepEndIndex = bops.find(dataBuffer,lineFeed)-1;
        if (sepEndIndex==-1) {
            //If there is no linefeed, then there is malformed input.
            throw "Error in bufferOps.js.parseMultipartFormdata: Malformed Input, separator line not found";
        }
        
        var sepBuffer = dataBuffer.slice(0,sepEndIndex);
        /* The splitBuffer will split the dataBuffer into its individual parts, for example, from:
        <
        -----------------------------18621512727577
        Content-Disposition: form-data; name="MAX_FILE_SIZE"
        
        500
        -----------------------------18621512727577
        Content-Disposition: form-data; name="uploadfile"; filename="ciphertext.txt"
        Content-Type: text/plain
        
        SIJYUMNVCAISPJLRBZEYQWYEULWMGWICJCIMTZEIMIBKNQWBRIVWYIGBWNBQQ
        -----------------------------18621512727577--
        >
        
        into:
        
        [<
        >,<
        Content-Disposition: form-data; name="MAX_FILE_SIZE"
        
        500
        >,<
        Content-Disposition: form-data; name="uploadfile"; filename="ciphertext.txt"
        Content-Type: text/plain
        
        SIJYUMNVCAISPJLRBZEYQWYEULWMGWICJCIMTZEIMIBKNQWBRIVWYIGBWNBQQ
        >,<
        --
        >]
        */
        var splitBuffer = bops.split(dataBuffer,sepBuffer);
        var firstLine = "";
        var firstLineIndex = 0;
        var name = "";
        var nameIndex = 0;
        var nameEndIndex = 0;
        var objectData = [];
        //Find the buffer containing the requested data
        // NOTE: the splitBuffer array will look like
        // [<>,...,<-->]
        // this means that we don't need to check the first or last elements of the array
        for (var i = 1; i<splitBuffer.length-1; i++) {
            //Get the index of the carriage return at the end of the second line
            firstLineIndex = bops.findAfter(splitBuffer[i],lineFeed,2)-1;
            if (firstLineIndex==-1) {
                //If there is no new line, then there is malformed input.
                throw "Error in bufferOps.js.parseMultipartFormdata: Malformed Input, newline not found";
            }
            //Get the first line
            firstLine = splitBuffer[i].slice(2,firstLineIndex);
            //Find the 'name="' string
            nameIndex = bops.find(firstLine,nameBuffer);
            if (nameIndex == -1) {
                throw "Error in bufferOps.js.parseMultipartFormdata: Malformed Input, name field not found";
            }
            nameIndex += nameBuffer.length;
            //If 'name="' is found, find the trailing quote
            nameEndIndex = bops.findAfter(firstLine,quoteBuffer,nameIndex);
            if (nameIndex == -1) {
                throw "Error in bufferOps.js.parseMultipartFormdata: Malformed Input, name field error";
            }
            //Finally, get the name
            name = firstLine.slice(nameIndex,nameEndIndex).toString();
            
            //Find the two newlines in a row, they indicate the start of the data
            startIndex = bops.find(splitBuffer[i],crlfcrlfBuffer);
            if (startIndex==-1) {
                throw "Error in bufferOps.js.parseMultipartFormdata: Malformed Input";
            }
            startIndex += crlfcrlfBuffer.length;
            //Now the first byte of the data is at startIndex
            // and the splitBuffer[i] section ends at the end of the data, so now it's easy
            //Just put the rest into the array, minus the trailing carriage return line feed
            objectData[name] = splitBuffer[i].slice(startIndex,splitBuffer[i].length-2);
        }
        return objectData;
};
exports.parseMultipartFormdata = parseMultipartFormdata;