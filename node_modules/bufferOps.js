/*
Written by: Mitchell Ludwig
*/

/* 
find takes as input two buffers. If the data in subBuffer is duplicated in sourceBuffer, 
then the index of the first character of the first occurence of the data is returned.
If the data is not duplicated, -1 is returned
This function is similar to the search() method for strings
*/
find = function (sourceBuffer, subBuffer) {
    //If the subbuffer is longer, it can't be a subbuffer, return -1.
    if (subBuffer.length>sourceBuffer.length) {
        return -1;
    } else {
        //If the subbuffer isn't longer, then check every possible slice from sourceBuffer
        //  which is the same length at subbuffer and see if they match
        for(var srcIndex=0;srcIndex<sourceBuffer.length-subBuffer.length+1;srcIndex++) {
            var slicedBuffer = sourceBuffer.slice(srcIndex,srcIndex+subBuffer.length);
            if (isMatch(slicedBuffer,subBuffer)) {
                return srcIndex;
            }
        }
        return -1;
    }
};
exports.find = find;

/*
findAfter is like find, except it begins searching the sourceBuffer at startIndex, instead of at the beginning
*/
findAfter = function (sourceBuffer, subBuffer, startIndex) {
    if (startIndex<sourceBuffer.length){
        if (startIndex>=0) {
            var foundIndex = find(sourceBuffer.slice(startIndex),subBuffer);
            if (foundIndex == -1) {
                return -1;
            } else {
                return foundIndex + startIndex;
            }
        }
    } else {
        return -1;
    }
};
exports.findAfter = findAfter;

/*
isMatch returns true if the two input buffers contain the same data
isMatch returns false otherwise
*/
isMatch = function (bfr1,bfr2) {
    //Buffers of different sizes won't match
    if (bfr1.length != bfr2.length) {
        return false;
    } else {
        //If one byte is different, return false
        for (var i=0;i<bfr1.length;i++) {
            if (bfr1[i]!=bfr2[i]) {
                return false;
            }
        }
        //If no bytes were different, return true
        return true;
    }
};
exports.isMatch = isMatch;

/*
join takes an array of Buffers and copies them into a single new Buffer
join returns a Buffer of length 0 if given an empty array
*/
join = function (bufferArray) {
    //If given an empty array as input, return a Buffer of length 0
    if (bufferArray.length==0) {
        return new Buffer(0);
    } else {
        //Calculate the length of the new Buffer by summing up the length of all the Buffers
        //   in the input array
        var totalLength = 0;
        for (var i = 0; i<bufferArray.length; i++) {
            totalLength = totalLength + bufferArray[i].length;
        }
        //Create the buffer to copy into
        var joinedBuffer = new Buffer(totalLength);
        //For keeping track of where we have copied to
        totalLength=0;
        //Copy every Buffer in bufferArray into the new Buffer
        for (var i = 0; i<bufferArray.length; i++) {
            bufferArray[i].copy(joinedBuffer,totalLength);
            totalLength = totalLength + bufferArray[i].length;
        }
        //And return the joined Buffer
        return joinedBuffer;
    }
};
exports.join = join;

/*
extractFileFromResponse returns a Buffer containing the first uploaded file
    when given an HTTP data section with enctype="multipart/form-data", stored in a Buffer.
    throws "Malformed Input" if the Buffer is not properly formatted as multipart/form-data
*/
extractFileFromResponse = function (dataBuffer) {
        //Buffer representing the linefeed character
        var lineFeed = new Buffer(1);
        lineFeed[0]=10;
        
        //Grab the first line, which separates all of the entries in the form data
        var sepEndIndex = find(dataBuffer,lineFeed)-1;
        if (sepEndIndex==-1) {
            //If there is no linefeed, then there is malformed input.
            throw "Malformed Input";
        }
        
        var sepBuffer = dataBuffer.slice(0,sepEndIndex);
        //Find the filename
        
        var startIndex = find(dataBuffer,new Buffer("filename="));
        if (startIndex==-1) {
            //If there is no filename, then there is malformed input.
            throw "Malformed Input";
        }
        //If filename is found, extract the actual contents of the file.
        //Go down three lines, if there are not 3 more lines, there is malformed input
        startIndex = findAfter(dataBuffer,lineFeed,startIndex+1);
        if (startIndex==-1) {
            throw "Malformed Input";
        }
        startIndex = findAfter(dataBuffer,lineFeed,startIndex+1);
        if (startIndex==-1) {
            throw "Malformed Input";
        }
        startIndex = findAfter(dataBuffer,lineFeed,startIndex+1);
        if (startIndex==-1) {
            throw "Malformed Input";
        }
        //Now the LineFeed right before the file is in startIndex
        startIndex++;
        //Now the first byte of the file is at startIndex
        //Now to find the end index, we look for the "------#######" in the buffer
        //But since we don't want to add the extra CRLF, we subtract 2
        var endIndex = findAfter(dataBuffer,sepBuffer,startIndex)-2
        if (endIndex==-1) {
            //If there is no end to the file, then there is malformed input
            throw "Malformed Input";
        }
        return dataBuffer.slice(startIndex,endIndex);
};
exports.extractFileFromResponse = extractFileFromResponse;