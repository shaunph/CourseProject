/*
Written by: Mitchell Ludwig
*/

/* 
find takes as input two buffers. If the data in subBuffer is duplicated in sourceBuffer, 
then the index of the first character of the first occurence of the data is returned.
If the data is not duplicated, -1 is returned
This function is similar to the search() method for strings
*/
find = function (sourceBuffer, subBuffer) {
    //If the subbuffer is longer, it can't be a subbuffer, return -1.
    if (subBuffer.length>sourceBuffer.length) {
        return -1;
    } else {
        //If the subbuffer isn't longer, then check every possible slice from sourceBuffer
        //  which is the same length at subbuffer and see if they match
        for(var srcIndex=0;srcIndex<sourceBuffer.length-subBuffer.length+1;srcIndex++) {
            var slicedBuffer = sourceBuffer.slice(srcIndex,srcIndex+subBuffer.length);
            if (isMatch(slicedBuffer,subBuffer)) {
                return srcIndex;
            }
        }
        return -1;
    }
};
exports.find = find;

/*
findAfter is like find, except it begins searching the sourceBuffer at startIndex, instead of at the beginning
findAfter returns -1 if startIndex > sourceBuffer.length
findAfter returns find(sourceBuffer,subBuffer) if startIndex = 0
*/
findAfter = function (sourceBuffer, subBuffer, startIndex) {
    if (startIndex<sourceBuffer.length){
        if (startIndex<0) {
            startIndex=0;
        }
        var foundIndex = find(sourceBuffer.slice(startIndex),subBuffer);
        if (foundIndex == -1) {
            return -1;
        } else {
            return foundIndex + startIndex;
        }
    } else {
        return -1;
    }
};
exports.findAfter = findAfter;

/*
isMatch returns true if the two input buffers contain the same data
isMatch returns false otherwise
*/
isMatch = function (bfr1,bfr2) {
    //Buffers of different sizes won't match
    if (bfr1.length != bfr2.length) {
        return false;
    } else {
        //If one byte is different, return false
        for (var i=0;i<bfr1.length;i++) {
            if (bfr1[i]!=bfr2[i]) {
                return false;
            }
        }
        //If no bytes were different, return true
        return true;
    }
};
exports.isMatch = isMatch;

/*
join takes an array of Buffers and copies them into a single new Buffer
join returns a Buffer of length 0 if given an empty array
*/
join = function (bufferArray) {
    //If given an empty array as input, return a Buffer of length 0
    if (bufferArray.length==0) {
        return new Buffer(0);
    } else {
        //Calculate the length of the new Buffer by summing up the length of all the Buffers
        //   in the input array
        var totalLength = 0;
        for (var i = 0; i<bufferArray.length; i++) {
            totalLength = totalLength + bufferArray[i].length;
        }
        //Create the buffer to copy into
        var joinedBuffer = new Buffer(totalLength);
        //For keeping track of where we have copied to
        totalLength=0;
        //Copy every Buffer in bufferArray into the new Buffer
        for (var i = 0; i<bufferArray.length; i++) {
            bufferArray[i].copy(joinedBuffer,totalLength);
            totalLength = totalLength + bufferArray[i].length;
        }
        //And return the joined Buffer
        return joinedBuffer;
    }
};
exports.join = join;


/*
split takes two Buffers as input and splits the first Buffer into
 an array of Buffers, as delimited by the second input Buffer. For example:
 bufferMain=<23 43 12 23 43 45 65 23 43 23 43>
 bufferDelimiter=<23 43>
 split(bufferMain,bufferDelimiter) returns [<>,<12>,<45 65>,<>,<>];
 bufferDelimiter can be of any size
split returns [bufferMain] if bufferDelimiter is not found in bufferMain
split returns [new Buffer(0)] if bufferMain is empty
*/
split = function (bufferMain,bufferDelimiter) {
    //If given an empty buffer as input, return an array with an empty buffer
    if (bufferMain.length==0) {
        return [new Buffer(0)];
    } else {
        //Initialize an array to hold the Buffers in
        var splitBuffer = [];
        var iPos = 0; //iPos indicates the next index to be added to the next
            // Buffer in splitBuffer
        var iNextPos = find(bufferMain,bufferDelimiter,iPos); //iNextPos is the
            // index of the next occurence of the delimiter Buffer's contents
            // in bufferMain
        //While there is another occurence of the delimiter
        while (iNextPos != -1) {
            //Add the next slice to the 
            splitBuffer[splitBuffer.length]=bufferMain.slice(iPos,iNextPos);
            iPos = iNextPos + bufferDelimiter.length;
            if (iPos<bufferMain.length) {
                iNextPos = findAfter(bufferMain,bufferDelimiter,iPos);
            } else {
                iNextPos = -1;
            }
        }
        splitBuffer[splitBuffer.length]=bufferMain.slice(iPos);
        return splitBuffer;
    }
};
exports.split = split;
